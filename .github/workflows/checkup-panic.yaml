name: Checkup Final

on:
  workflow_dispatch:
    inputs:
      buildError1:
        description: ""
        type: boolean
        required: false
        default: false
      buildError2:
        description: ""
        type: boolean
        required: false
        default: false
      AlgoliaError1:
        description: ""
        type: boolean
        required: false
        default: false
      AlgoliaError2:
        description: ""
        type: boolean
        required: false
        default: false

jobs:
  appsec-android-native-job:
    uses: ./.github/workflows/reuseable_workflow.yaml
    with:
      ibe: ${{ inputs.buildError1 }}
      iae: false
      targetRepo: digital-ai/docs-appsec-android-native # Use actual repo name
        # secrets: inherit

  deploy-job:
    uses: ./.github/workflows/reuseable_workflow.yaml
    with:
      ibe: false
      iae: ${{ inputs.AlgoliaError1 }}
      targetRepo: digital-ai/docs-deploy # Use actual repo name

  release-job:
    uses: ./.github/workflows/reuseable_workflow.yaml
    with:
      ibe: ${{ inputs.buildError2 }}
      iae: ${{ inputs.AlgoliaError1 }}
      targetRepo: digital-ai/docs-release # Use actual repo name

  platform-job:
    uses: ./.github/workflows/reuseable_workflow.yaml
    with:
      ibe: false
      iae: false
      targetRepo: digital-ai/docs-platform # Use actual repo name

  appsec-final-job:
    uses: ./.github/workflows/reuseable_workflow.yaml
    with:
      ibe: false
      iae: ${{ inputs.AlgoliaError1 }}
      targetRepo: digital-ai/docs-appsec-final # Use actual repo name
  
  check_failures:
    name: Check Failures and Notify
    runs-on: ubuntu-latest
    if: always()
    needs:
      - appsec-android-native-job # Depends on initial job
      - deploy-job  # Depends on all middle jobs
      - release-job
      - platform-job  
      - appsec-final-job # Depends on final job
      # Add all other middle job IDs here

    steps:
      - name: Aggregate Job Results
        id: aggregate
        uses: actions/github-script@v7
        with:
          script: |
            const needs_context = ${{ toJson(needs) }};
            console.log("Needs Context:", JSON.stringify(needs_context, null, 2));

            // --- Map Job IDs to Repository Names ---
            // Crucial for identifying skipped jobs correctly
            const jobToRepoMap = {
              'crawl_repo_1_initial': 'docs-repo-1',
              'crawl_repo_2_middle':  'docs-repo-2',
              'crawl_repo_3_middle':  'docs-repo-3',
              'crawl_repo_4_middle':  'docs-repo-4',
              'crawl_repo_5_final':   'docs-repo-5'
              // Add mappings for ALL jobs listed in 'needs' above
            };
            // --- --- --- --- --- --- --- --- --- ---

            let build_failures = [];
            let algolia_failures = [];
            let skipped_jobs = [];
            let unknown_failures = [];
            let has_issues = false; // Use a broader term than just 'failures'

            const job_ids = Object.keys(needs_context);

            for (const job_id of job_ids) {
              const job_result = needs_context[job_id];
              const repo_name = jobToRepoMap[job_id] || job_id; // Get repo name from map

              // Check job status: failure, skipped, cancelled, etc. (exclude success)
              if (job_result.result !== 'success') {
                has_issues = true;
                console.log(`Issue detected for Job ID: ${job_id} (Repo: ${repo_name}). Result: ${job_result.result}`);

                if (job_result.result === 'skipped') {
                  skipped_jobs.push(`${repo_name} (Skipped - likely upstream failure)`);
                } else if (job_result.result === 'failure') {
                  // Job ran but failed, check its output status
                  const status = job_result.outputs?.status; // Use optional chaining ?.
                  if (status === 'build_failure') {
                    build_failures.push(repo_name);
                  } else if (status === 'algolia_failure') {
                    algolia_failures.push(repo_name);
                  } else {
                    // Failure occurred, but status wasn't set or recognized
                    unknown_failures.push(`${repo_name} (Job Failed - Status: ${status || 'N/A'})`);
                  }
                } else {
                  // Handle other non-success states like 'cancelled' if necessary
                   unknown_failures.push(`${repo_name} (Job State: ${job_result.result})`);
                }
              } else {
                 console.log(`Job ${job_id} (Repo: ${repo_name}) completed successfully.`);
              }
            }

            let slack_message = "ALGOLIA CRAWL SUCCESS";
            if (has_issues) {
              slack_message += `*GitHub Actions: Doc Crawl Workflow completed with issues* :warning:\n`;
              slack_message += `Workflow Run: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}\n\n`;

              if (build_failures.length > 0) {
                slack_message += `*Build Failures* :x::\n - ${build_failures.join('\n - ')}\n\n`;
              }
              if (algolia_failures.length > 0) {
                slack_message += `*Algolia Crawler Failures* (Check logs for 'panic:' or connection issues) :spider_web::\n - ${algolia_failures.join('\n - ')}\n\n`;
              }
               if (skipped_jobs.length > 0) {
                slack_message += `*Skipped Jobs* (Did not run due to upstream failure) :next_track_button::\n - ${skipped_jobs.join('\n - ')}\n\n`;
              }
              if (unknown_failures.length > 0) {
                 slack_message += `*Unknown/Other Issues* :question::\n - ${unknown_failures.join('\n - ')}\n\n`;
              }
            } else {
               console.log("All jobs completed successfully.");
               // Optionally send a success message or take no action
               // slack_message = "*GitHub Actions: Doc Crawl Workflow completed successfully* :white_check_mark:";
            }

            core.setOutput('slack_message', slack_message);
            // Output true if there were *any* issues (failures or skips)
            core.setOutput('has_issues', has_issues.toString());

      - name: Send Slack Notification on Issues
        # if: steps.aggregate.outputs.has_issues == 'true' && steps.aggregate.outputs.slack_message != ''
        run: |
          echo "${{ steps.aggregate.outputs.has_issues }}"
          echo "${{ steps.aggregate.outputs.slack_message }}"